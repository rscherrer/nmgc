model <- as.formula(paste(grouping, "~", paste(variables, collapse = " + ")))
if (method == "SVM") {
# Fit a support vector machine to the data
machine <- fit(model, data = data[training,], model = "svm", kernel = "rbfdot", task = "class")
} else if (method == "LDA") {
# Or a linear discriminant analysis
machine <- lda(formula = model, data = data[training,])
} else stop("unknown method")
# Sensitivity analysis of the fitted model (early exit)
imp <- NULL
if (importance) {
imp <- Importance(machine, data = data[training,])$imp[which(colnames(data) %in% variables)]
names(imp) <- variables
}
# Predict the labels of the remaining data
predictions <- predict(machine, newdata = data[groups == i, variables])
if (method == "LDA") predictions <- predictions$class
# Compare true and predicted labels
conf <- table(predictions, data[groups == i, grouping])
if (!return_machine) machine <- NULL
return (list(conf = conf, imp = imp, machine = machine))
})
})
})
if (digest) {
confs <- results %>% map(~ map(.x, ~ map(.x, "conf")))
avg <- confs %>% map(~ mavg(.x %>% map(mavg)))
accu <- confs %>% map(~ do.call("c" , .x)) %>% map_dfr(~ map_dbl(.x, pdiag)) %>% gather(key = "nesting", value = "accu")
mean <- accu %>% group_by(nesting) %>% summarize(accu = mean(accu))
if (importance) {
imp <- results %>% map(~ .x %>% map_dfr(~ do.call("rbind", .x %>% map(~ pluck(.x, "imp"))) %>% data.frame())) %>%
map2_dfr(names(.), ~ .x %>% mutate(nesting = .y))
} else imp <- NULL
if (test) {
mean <- mean %>%
mutate(
n = map_int(data, nrow),
ptest = ptesting,
ntest = floor(ptest * n),
pvalue = 1 - pbinom(accu * ntest, size = ntest, prob = 1 / length(labels))
)
}
if (!nested) {
avg <- avg[[1]]
accu <- accu$accu
confs <- confs[[1]]
}
return (list(mean = mean, avg = avg, accu = accu, confs = confs, imp = imp))
}
if (!nested) results <- results[[1]]
return (results)
}
rm(list = ls())
library(nmgc)
library(tidyverse)
data <- read.csv("data/reflectance.csv", header = TRUE)
npcomp(data, c("wl300", "wl400", "wl500"))$x %>% head
classify(data, c("PC1", "PC2"), grouping = "habitat", nesting = "island",
to_pcomp = c("wl300", "wl500"), digest = TRUE, test = TRUE)$mean
#' Nested principal component analysis
#'
#' Perform principal component analyses across multiple subsets of the data
#'
#' @param data A data frame
#' @param variables The variables to analyze
#' @param center Whether to center the data
#' @param scale Whether to scale the data
#' @param nesting Optional nesting factor indicating the subsets. Defaults to NULL, where the output is that of a regular call to `prcomp`
#' @param combine If `nesting` is provided, whether to combine the results for the different subsets.
#' @param reduce If `combine` is TRUE, what principal components to retain from across the subsets.
#'
#' @return If `nesting` is NULL, the same as `prcomp`, otherwise, if `combine` is FALSE, a nested list of `prcomp` outputs, one for each subset. If `combine` is TRUE, a list of three data frames:
#' \itemize{
#' \item{`sdev`}{Contains the standard deviations along each principal component for each subset}
#' \item{`rotation`}{Contains the rotation matrices for each subset, bound by row}
#' \item{`x`}{The scores of each observation on each principal component}
#' }
#'
#' @export
npcomp <- function(data, variables, center = TRUE, scale = TRUE, nesting = NULL, combine = TRUE, reduce = NULL) {
library(tidyverse)
if (is.null(nesting)) data <- list(data) else data <- data %>% split(.[[nesting]])
data <- data %>% map(~ .x %>% dplyr::select(all_of(variables)) %>% prcomp(center = center, scale = scale))
if (is.null(nesting)) return(data[[1]])
out <- data
if (combine) {
fields <- c("sdev", "rotation", "x")
names(fields) <- fields
out <- fields %>% map(function(field) {
out <- data %>%
map(
~ .x[[field]] %>%
rbind %>%
data.frame %>%
rename_all(str_replace, "X", "PC") %>%
select(all_of(reduce)) %>%
rownames_to_column
) %>%
map2(names(.), ~ .x %>% mutate(nesting = .y)) %>%
do.call("rbind", .) %>%
remove_rownames()
if (field != "rotation") out <- out %>% select(-rowname)
out <- out %>% .[, c(ncol(.), 1:(ncol(.) - 1))]
colnames(out) <- colnames(out) %>%
str_replace("nesting", nesting) %>%
str_replace("rowname", "variable")
return (out)
})
}
return(out)
}
#' Classification analysis
#'
#' Perform a replicated classification analysis of a multivariate dataset into categorical labels using machine learning tools and k-fold cross validation
#'
#' @param data A data frame
#' @param variables The variables used to classify
#' @param grouping Name of the grouping variable (the labels)
#' @param nesting Optional nesting variable, if the analysis must be conducted separately on different subsets of the data
#' @param method The data mining model used. Currently supports "SVM" and "LDA".
#' @param k Number of bins for the k-fold cross-validation procedure
#' @param nrep Number of replicate analyses (i.e. number of k-fold cross validations)
#' @param minsize Minimum size required per group for a training data set
#' @param seed Optional random seed to reset at the beginning
#' @param importance Whether to perform sensitivity analysis on the input (takes a while)
#' @param return_machine Whether to return the machines (takes space)
#' @param verbose Whether to display messages
#' @param pb Whether to display progress bars
#' @param digest Whether to return the results in a summarized format
#' @param test Whether to test the results against random guessing using a binomial distribution
#' @param pcomp Whether to work on principal component data
#' @param center Center the PCA
#' @param scale Scale the PCA
#'
#' @return A list containing the results. If `digest` is `FALSE`, a nested list on two levels with, for each replicate (first level) cross-validation bin (second level), i.e. for each machine, the following fields:
#' \itemize{
#' \item{`conf`}{The confusion matrix resulting from testing the machine}
#' \item{`imp`}{A vector of relative importance of input variable}
#' \item{`machine`}{The machine itself}
#' }
#' or a list of such nested lists if `nesting` is provided, with one nested list per subset of the data.
#' If `digest` is TRUE, returns a list with the following fields:
#' \itemize{
#' \item{`mean`}{A data frame with a column "accu" containing the mean accuracy across all machines on a single row, or accuracies over subsets of the data on multiple rows if `nesting` is provided. If `test` is `TRUE`, extra columns are added, containing the number of observations, "n", the proportion of observations used in testing the machines, "ptest", the number of observations in a testing set, "ntest", the binomial P-value assessing the significance of the obtained result, "pvalue".}
#' \item{`avg`}{The average over replicates of the average confusion matrices over cross-validation bins, or a list of those if `nesting` is provided}
#' \item{`accu`}{A vector of classification accuracy across all machines, or a data frame with a column for the nesting variable if `nesting` is provided}
#' \item{`confs`}{A nested list on two levels of confusion matrices, per replicate and cross-validation bin, or a list of such nested lists if `nesting` is provided}
#' \item{`imp`}{A data frame with the relative importance of each input variable for each machine, with an extra column with a nesting variable if `nesting` is provided}
#' }
#'
#' @export
classify <- function(
data,
variables,
grouping,
nesting = NULL,
method = "SVM",
k = 5,
nrep = 1,
minsize = 5,
seed = NULL,
importance = FALSE,
return_machine = FALSE,
verbose = TRUE,
pb = TRUE,
digest = TRUE,
test = TRUE,
to_pcomp = NULL,
center = TRUE,
scale = TRUE
) {
library(rminer)
library(MASS)
library(assertthat)
library(tidyverse)
library(pbapply)
if (!is.null(to_pcomp)) data <- data %>%
cbind(npcomp(data, to_pcomp, center, scale, nesting, combine = TRUE, reduce = variables)$x)
# Random seed
if (!is.null(seed)) set.seed(seed)
ptesting <- 1 / k
assert_that(nrow(data) > k)
assert_that(floor(ptesting * nrow(data)) > 0)
# Define the possible labels
labels <- levels(data[, grouping])
nested <- TRUE
if (is.null(nesting)) {
nested <- FALSE
data$nesting <- factor(1)
nesting <- "nesting"
}
data <- data %>% split(f = .[, nesting])
if (!verbose) pb <- FALSE
thislapply1 <- thislapply2 <- lapply
if (pb) if (nested) thislapply1 <- pblapply else thislapply2 <- pblapply
results <- thislapply1(data, function(data) {
thislapply2(seq(nrep), function(i) {
is_fine <- FALSE
while (!is_fine) {
# Randomly assign data to k testing groups
groups <- rep(seq_len(k), each = floor(ptesting * nrow(data)))
if (length(groups) < nrow(data)) groups <- c(groups, seq_len(nrow(data) - length(groups)))
assert_that(length(groups) == nrow(data))
groups <- sample(groups, replace = FALSE)
# Check that each label is sufficiently represented within each training group
is_fine <- all(sapply(seq_len(k), function(i) {
represented <- table(data[which(groups != i), grouping])
if (!all(labels %in% names(represented))) return (FALSE)
return (all(represented > minsize))
}))
}
# For each testing group...
lapply(seq_len(k), function(i) {
# Sample indices for a training dataset
training <- which(groups != i)
assert_that(length(training) < nrow(data))
# Downsample the training dataset to the size of the least represented label
targetsize <- min(table(data[training, grouping]))
training <- do.call("c", lapply(labels, function(lab) sample(training[data[training, grouping] == lab], targetsize, replace = FALSE)))
assert_that(all(table(data[training, grouping]) == targetsize))
# Set up model formula
model <- as.formula(paste(grouping, "~", paste(variables, collapse = " + ")))
if (method == "SVM") {
# Fit a support vector machine to the data
machine <- fit(model, data = data[training,], model = "svm", kernel = "rbfdot", task = "class")
} else if (method == "LDA") {
# Or a linear discriminant analysis
machine <- lda(formula = model, data = data[training,])
} else stop("unknown method")
# Sensitivity analysis of the fitted model (early exit)
imp <- NULL
if (importance) {
imp <- Importance(machine, data = data[training,])$imp[which(colnames(data) %in% variables)]
names(imp) <- variables
}
# Predict the labels of the remaining data
predictions <- predict(machine, newdata = data[groups == i, variables])
if (method == "LDA") predictions <- predictions$class
# Compare true and predicted labels
conf <- table(predictions, data[groups == i, grouping])
if (!return_machine) machine <- NULL
return (list(conf = conf, imp = imp, machine = machine))
})
})
})
if (digest) {
confs <- results %>% map(~ map(.x, ~ map(.x, "conf")))
avg <- confs %>% map(~ mavg(.x %>% map(mavg)))
accu <- confs %>% map(~ do.call("c" , .x)) %>% map_dfr(~ map_dbl(.x, pdiag)) %>% gather(key = "nesting", value = "accu")
mean <- accu %>% group_by(nesting) %>% summarize(accu = mean(accu))
if (importance) {
imp <- results %>% map(~ .x %>% map_dfr(~ do.call("rbind", .x %>% map(~ pluck(.x, "imp"))) %>% data.frame())) %>%
map2_dfr(names(.), ~ .x %>% mutate(nesting = .y))
} else imp <- NULL
if (test) {
mean <- mean %>%
mutate(
n = map_int(data, nrow),
ptest = ptesting,
ntest = floor(ptest * n),
pvalue = 1 - pbinom(accu * ntest, size = ntest, prob = 1 / length(labels))
)
}
if (!nested) {
avg <- avg[[1]]
accu <- accu$accu
confs <- confs[[1]]
}
return (list(mean = mean, avg = avg, accu = accu, confs = confs, imp = imp))
}
if (!nested) results <- results[[1]]
return (results)
}
classify(data, c("PC1", "PC2"), grouping = "habitat", nesting = "island",
to_pcomp = c("wl300", "wl500"), digest = TRUE, test = TRUE)$mean
#' Nested principal component analysis
#'
#' Perform principal component analyses across multiple subsets of the data
#'
#' @param data A data frame
#' @param variables The variables to analyze
#' @param center Whether to center the data
#' @param scale Whether to scale the data
#' @param nesting Optional nesting factor indicating the subsets. Defaults to NULL, where the output is that of a regular call to `prcomp`
#' @param combine If `nesting` is provided, whether to combine the results for the different subsets.
#' @param reduce If `combine` is TRUE, what principal components to retain from across the subsets.
#'
#' @return If `nesting` is NULL, the same as `prcomp`, otherwise, if `combine` is FALSE, a nested list of `prcomp` outputs, one for each subset. If `combine` is TRUE, a list of three data frames:
#' \itemize{
#' \item{`sdev`}{Contains the standard deviations along each principal component for each subset}
#' \item{`rotation`}{Contains the rotation matrices for each subset, bound by row}
#' \item{`x`}{The scores of each observation on each principal component}
#' }
#'
#' @export
npcomp <- function(data, variables, center = TRUE, scale = TRUE, nesting = NULL, combine = TRUE, reduce = NULL) {
library(tidyverse)
if (is.null(nesting)) data <- list(data) else data <- data %>% split(.[[nesting]])
data <- data %>% map(~ .x %>% dplyr::select(all_of(variables)) %>% prcomp(center = center, scale = scale))
if (is.null(nesting)) return(data[[1]])
out <- data
if (combine) {
fields <- c("sdev", "rotation", "x")
names(fields) <- fields
out <- fields %>% map(function(field) {
out <- data %>%
map(
~ .x[[field]] %>%
rbind %>%
data.frame %>%
rename_all(str_replace, "X", "PC") %>%
dplyr::select(all_of(reduce)) %>%
rownames_to_column
) %>%
map2(names(.), ~ .x %>% mutate(nesting = .y)) %>%
do.call("rbind", .) %>%
remove_rownames()
if (field != "rotation") out <- out %>% select(-rowname)
out <- out %>% .[, c(ncol(.), 1:(ncol(.) - 1))]
colnames(out) <- colnames(out) %>%
str_replace("nesting", nesting) %>%
str_replace("rowname", "variable")
return (out)
})
}
return(out)
}
#' Classification analysis
#'
#' Perform a replicated classification analysis of a multivariate dataset into categorical labels using machine learning tools and k-fold cross validation
#'
#' @param data A data frame
#' @param variables The variables used to classify
#' @param grouping Name of the grouping variable (the labels)
#' @param nesting Optional nesting variable, if the analysis must be conducted separately on different subsets of the data
#' @param method The data mining model used. Currently supports "SVM" and "LDA".
#' @param k Number of bins for the k-fold cross-validation procedure
#' @param nrep Number of replicate analyses (i.e. number of k-fold cross validations)
#' @param minsize Minimum size required per group for a training data set
#' @param seed Optional random seed to reset at the beginning
#' @param importance Whether to perform sensitivity analysis on the input (takes a while)
#' @param return_machine Whether to return the machines (takes space)
#' @param verbose Whether to display messages
#' @param pb Whether to display progress bars
#' @param digest Whether to return the results in a summarized format
#' @param test Whether to test the results against random guessing using a binomial distribution
#' @param pcomp Whether to work on principal component data
#' @param center Center the PCA
#' @param scale Scale the PCA
#'
#' @return A list containing the results. If `digest` is `FALSE`, a nested list on two levels with, for each replicate (first level) cross-validation bin (second level), i.e. for each machine, the following fields:
#' \itemize{
#' \item{`conf`}{The confusion matrix resulting from testing the machine}
#' \item{`imp`}{A vector of relative importance of input variable}
#' \item{`machine`}{The machine itself}
#' }
#' or a list of such nested lists if `nesting` is provided, with one nested list per subset of the data.
#' If `digest` is TRUE, returns a list with the following fields:
#' \itemize{
#' \item{`mean`}{A data frame with a column "accu" containing the mean accuracy across all machines on a single row, or accuracies over subsets of the data on multiple rows if `nesting` is provided. If `test` is `TRUE`, extra columns are added, containing the number of observations, "n", the proportion of observations used in testing the machines, "ptest", the number of observations in a testing set, "ntest", the binomial P-value assessing the significance of the obtained result, "pvalue".}
#' \item{`avg`}{The average over replicates of the average confusion matrices over cross-validation bins, or a list of those if `nesting` is provided}
#' \item{`accu`}{A vector of classification accuracy across all machines, or a data frame with a column for the nesting variable if `nesting` is provided}
#' \item{`confs`}{A nested list on two levels of confusion matrices, per replicate and cross-validation bin, or a list of such nested lists if `nesting` is provided}
#' \item{`imp`}{A data frame with the relative importance of each input variable for each machine, with an extra column with a nesting variable if `nesting` is provided}
#' }
#'
#' @export
classify <- function(
data,
variables,
grouping,
nesting = NULL,
method = "SVM",
k = 5,
nrep = 1,
minsize = 5,
seed = NULL,
importance = FALSE,
return_machine = FALSE,
verbose = TRUE,
pb = TRUE,
digest = TRUE,
test = TRUE,
to_pcomp = NULL,
center = TRUE,
scale = TRUE
) {
library(rminer)
library(MASS)
library(assertthat)
library(tidyverse)
library(pbapply)
if (!is.null(to_pcomp)) data <- data %>%
cbind(npcomp(data, to_pcomp, center, scale, nesting, combine = TRUE, reduce = variables)$x)
# Random seed
if (!is.null(seed)) set.seed(seed)
ptesting <- 1 / k
assert_that(nrow(data) > k)
assert_that(floor(ptesting * nrow(data)) > 0)
# Define the possible labels
labels <- levels(data[, grouping])
nested <- TRUE
if (is.null(nesting)) {
nested <- FALSE
data$nesting <- factor(1)
nesting <- "nesting"
}
data <- data %>% split(f = .[, nesting])
if (!verbose) pb <- FALSE
thislapply1 <- thislapply2 <- lapply
if (pb) if (nested) thislapply1 <- pblapply else thislapply2 <- pblapply
results <- thislapply1(data, function(data) {
thislapply2(seq(nrep), function(i) {
is_fine <- FALSE
while (!is_fine) {
# Randomly assign data to k testing groups
groups <- rep(seq_len(k), each = floor(ptesting * nrow(data)))
if (length(groups) < nrow(data)) groups <- c(groups, seq_len(nrow(data) - length(groups)))
assert_that(length(groups) == nrow(data))
groups <- sample(groups, replace = FALSE)
# Check that each label is sufficiently represented within each training group
is_fine <- all(sapply(seq_len(k), function(i) {
represented <- table(data[which(groups != i), grouping])
if (!all(labels %in% names(represented))) return (FALSE)
return (all(represented > minsize))
}))
}
# For each testing group...
lapply(seq_len(k), function(i) {
# Sample indices for a training dataset
training <- which(groups != i)
assert_that(length(training) < nrow(data))
# Downsample the training dataset to the size of the least represented label
targetsize <- min(table(data[training, grouping]))
training <- do.call("c", lapply(labels, function(lab) sample(training[data[training, grouping] == lab], targetsize, replace = FALSE)))
assert_that(all(table(data[training, grouping]) == targetsize))
# Set up model formula
model <- as.formula(paste(grouping, "~", paste(variables, collapse = " + ")))
if (method == "SVM") {
# Fit a support vector machine to the data
machine <- fit(model, data = data[training,], model = "svm", kernel = "rbfdot", task = "class")
} else if (method == "LDA") {
# Or a linear discriminant analysis
machine <- lda(formula = model, data = data[training,])
} else stop("unknown method")
# Sensitivity analysis of the fitted model (early exit)
imp <- NULL
if (importance) {
imp <- Importance(machine, data = data[training,])$imp[which(colnames(data) %in% variables)]
names(imp) <- variables
}
# Predict the labels of the remaining data
predictions <- predict(machine, newdata = data[groups == i, variables])
if (method == "LDA") predictions <- predictions$class
# Compare true and predicted labels
conf <- table(predictions, data[groups == i, grouping])
if (!return_machine) machine <- NULL
return (list(conf = conf, imp = imp, machine = machine))
})
})
})
if (digest) {
confs <- results %>% map(~ map(.x, ~ map(.x, "conf")))
avg <- confs %>% map(~ mavg(.x %>% map(mavg)))
accu <- confs %>% map(~ do.call("c" , .x)) %>% map_dfr(~ map_dbl(.x, pdiag)) %>% gather(key = "nesting", value = "accu")
mean <- accu %>% group_by(nesting) %>% summarize(accu = mean(accu))
if (importance) {
imp <- results %>% map(~ .x %>% map_dfr(~ do.call("rbind", .x %>% map(~ pluck(.x, "imp"))) %>% data.frame())) %>%
map2_dfr(names(.), ~ .x %>% mutate(nesting = .y))
} else imp <- NULL
if (test) {
mean <- mean %>%
mutate(
n = map_int(data, nrow),
ptest = ptesting,
ntest = floor(ptest * n),
pvalue = 1 - pbinom(accu * ntest, size = ntest, prob = 1 / length(labels))
)
}
if (!nested) {
avg <- avg[[1]]
accu <- accu$accu
confs <- confs[[1]]
}
return (list(mean = mean, avg = avg, accu = accu, confs = confs, imp = imp))
}
if (!nested) results <- results[[1]]
return (results)
}
npcomp(data, c("wl300", "wl400", "wl500"))$x %>% head
classify(data, c("PC1", "PC2"), grouping = "habitat", nesting = "island",
to_pcomp = c("wl300", "wl500"), digest = TRUE, test = TRUE)$mean
library(nmgc)
rm(list = ls())
library(nmgc)
library(tidyverse)
data <- read.csv("data/reflectance.csv", header = TRUE)
npcomp(data, c("wl300", "wl400", "wl500"))$x %>% head
classify(data, c("PC1", "PC2"), grouping = "habitat", nesting = "island",
to_pcomp = c("wl300", "wl500"), digest = TRUE, test = TRUE)$mean
library(nmgc)
rm(list = ls())
library(nmgc)
library(tidyverse)
data <- read.csv("data/reflectance.csv", header = TRUE)
npcomp(data, c("wl300", "wl400", "wl500"))$x %>% head
classify(data, c("PC1", "PC2"), grouping = "habitat", nesting = "island",
to_pcomp = c("wl300", "wl500"), digest = TRUE, test = TRUE)$mean
library(roxygen2)
roxygenise()
roxygenise()
library(nmgc)
